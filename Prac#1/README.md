# Варіант 14. Реалізувати декоратор, який кешує результати викликів функції.

## Опис
Цей проєкт демонструє різні способи реалізації кешування в Python за допомогою трьох окремих програм:
1. `caching_example.py` - Використовує вбудований `functools.lru_cache`.
2. `custom_cache_decorator.py` - Реалізує власний декоратор кешування.
3. `custom_cache_program.py` - Використовує власний декоратор кешування для аналізу частоти слів у текстовому файлі.

Кожна програма демонструє різні техніки кешування для підвищення продуктивності шляхом збереження раніше обчислених результатів і повторного їх використання при тих самих вхідних даних.

---

## Опис програм

### 1. `caching_example.py`
Ця програма обчислює послідовність Фібоначчі, використовуючи `functools.lru_cache`.

#### **Як це працює:**
- Декоратор `@lru_cache(maxsize=10)` кешує останні 10 обчислених значень.
- Це запобігає повторним обчисленням і прискорює виконання.
- Якщо `n` вже є в кеші, результат витягується збереженим значенням замість повторного обчислення.

#### **Основні особливості:**
- Використовує вбудоване **кешування за принципом останнього використання (LRU)**.
- Ефективне для рекурсивних функцій, таких як Фібоначчі.
- Обмежений розмір кешу (10) дозволяє контролювати використання пам’яті.

---

### 2. `custom_cache_decorator.py`
Ця програма реалізує **власний декоратор кешування** для збереження раніше обчислених чисел Фібоначчі.

#### **Як це працює:**
- Словник `cache` зберігає обчислені значення Фібоначчі.
- Якщо функція викликається з тим самим аргументом, результат повертається з кешу.
- На відміну від `lru_cache`, цей варіант **не обмежує** розмір кешу.

#### **Основні особливості:**
- Демонструє **ручну реалізацію кешування**.
- Не має механізму видалення застарілих даних, як у LRU.
- Може спричиняти **високе використання пам’яті** для великих значень `n`.

---

### 3. `custom_cache_program.py`
Ця програма застосовує **власний декоратор кешування** для оптимізації аналізу частоти слів у текстовому файлі.

#### **Як це працює:**
- Зчитує текстовий файл і підраховує частоту появи слів.
- Якщо той самий файл аналізується повторно, результат отримується з кешу замість повторного обчислення.
- Використовує `Counter` з модуля `collections` для ефективного підрахунку слів.
- Зберігає результати у форматах JSON та CSV для подальшого використання.

#### **Основні особливості:**
- Демонструє кешування для **обробки файлів**.
- Запобігає повторному аналізу тих самих даних.
- Зберігає результати у `word_frequency.json` та `word_frequency.csv`.

---

## Висновок
Ці програми ілюструють різні підходи до кешування в Python. Використання `functools.lru_cache` є найпростішим і найефективнішим варіантом для рекурсивних функцій, тоді як власний декоратор кешування надає гнучкість для застосування в різних сценаріях.

Завдяки кешуванню можна значно зменшити час обчислень і покращити продуктивність при повторній обробці тих самих запитів.

